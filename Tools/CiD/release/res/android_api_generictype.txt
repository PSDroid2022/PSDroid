<java.util.concurrent.AbstractExecutorService: java.util.concurrent.Future submit(java.lang.Runnable,T)>
<java.util.concurrent.BlockingQueue: E poll(long,java.util.concurrent.TimeUnit)>
<java.util.NavigableSet: E pollFirst()>
<java.util.Map.Entry: V getValue()>
<java.util.concurrent.BlockingQueue: E take()>
<java.util.stream.DoubleStream: R collect(java.util.function.Supplier,java.util.function.ObjDoubleConsumer,java.util.function.BiConsumer)>
<java.util.concurrent.CopyOnWriteArrayList: E set(int,E)>
<java.util.Collections: java.util.Map singletonMap(K,V)>
<java.util.TreeMap: java.util.Map.Entry higherEntry(K)>
<java.util.Hashtable: V computeIfPresent(K,java.util.function.BiFunction)>
<android.util.LongSparseArray: E get(long,E)>
<java.util.concurrent.atomic.AtomicMarkableReference: boolean weakCompareAndSet(V,V,boolean,boolean)>
<java.util.Deque: E poll()>
<java.util.concurrent.ConcurrentHashMap: V putIfAbsent(K,V)>
<java.util.concurrent.DelayQueue: void put(E)>
<java.util.concurrent.ConcurrentLinkedDeque: E peek()>
<java.util.concurrent.atomic.AtomicMarkableReference: void set(V,boolean)>
<java.util.concurrent.ForkJoinTask: V join()>
<java.util.TreeMap: java.util.SortedMap headMap(K)>
<java.util.concurrent.ArrayBlockingQueue: E poll()>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: int getAndUpdate(T,java.util.function.IntUnaryOperator)>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: boolean weakCompareAndSet(T,long,long)>
<java.nio.channels.ServerSocketChannel: java.nio.channels.ServerSocketChannel setOption(java.net.SocketOption,T)>
<java.util.Optional: T get()>
<android.os.RemoteCallbackList: boolean unregister(E)>
<org.apache.http.client.ResponseHandler: T handleResponse(org.apache.http.HttpResponse)>
<android.icu.util.Freezable: T freeze()>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: long getAndUpdate(T,java.util.function.LongUnaryOperator)>
<java.util.TreeSet: E pollLast()>
<java.lang.ref.SoftReference: void <init>(T)>
<java.util.concurrent.LinkedBlockingQueue: E poll(long,java.util.concurrent.TimeUnit)>
<android.util.LruCache: V remove(K)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: int incrementAndGet(T)>
<android.widget.ArrayAdapter: void remove(T)>
<java.util.NavigableSet: java.util.NavigableSet subSet(E,boolean,E,boolean)>
<java.util.Collections: T min(java.util.Collection)>
<android.util.Range: android.util.Range extend(T)>
<java.util.ArrayDeque: E removeLast()>
<java.util.AbstractList: E set(int,E)>
<java.util.concurrent.ConcurrentSkipListMap: V getOrDefault(java.lang.Object,V)>
<java.util.Vector: void addElement(E)>
<org.apache.http.impl.client.AbstractHttpClient: T execute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.client.ResponseHandler)>
<java.lang.Enum: T valueOf(java.lang.Class,java.lang.String)>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: void lazySet(T,long)>
<java.util.concurrent.Future: V get(long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.LinkedBlockingDeque: E peekLast()>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: void lazySet(T,int)>
<java.util.stream.BaseStream: S parallel()>
<android.util.IntProperty: void setValue(T,int)>
<java.util.concurrent.atomic.AtomicReference: V getAndUpdate(java.util.function.UnaryOperator)>
<java.util.concurrent.ConcurrentNavigableMap: java.util.concurrent.ConcurrentNavigableMap headMap(K,boolean)>
<java.util.NavigableSet: E pollLast()>
<android.animation.ObjectAnimator: android.animation.ObjectAnimator ofArgb(T,android.util.Property,int...)>
<android.animation.PropertyValuesHolder: android.animation.PropertyValuesHolder ofObject(android.util.Property,android.animation.TypeConverter,android.animation.TypeEvaluator,T...)>
<java.util.Hashtable: V replace(K,V)>
<android.util.LongSparseArray: E valueAt(int)>
<android.util.SparseArray: E get(int)>
<android.test.RenamingDelegatingContext: T providerWithRenamedContext(java.lang.Class,android.content.Context,java.lang.String,boolean)>
<java.util.concurrent.ConcurrentLinkedDeque: E pop()>
<java.util.List: E remove(int)>
<java.lang.Package: A getAnnotation(java.lang.Class)>
<java.util.function.BiPredicate: boolean test(T,U)>
<java.util.NavigableSet: java.util.NavigableSet tailSet(E,boolean)>
<java.util.concurrent.ArrayBlockingQueue: E poll(long,java.util.concurrent.TimeUnit)>
<android.hardware.camera2.CameraCharacteristics: T get(android.hardware.camera2.CameraCharacteristics.Key)>
<java.util.concurrent.ConcurrentLinkedDeque: E getFirst()>
<android.text.style.TtsSpan.SemioticClassBuilder: C setCase(java.lang.String)>
<java.util.concurrent.atomic.AtomicReferenceArray: E accumulateAndGet(int,E,java.util.function.BinaryOperator)>
<java.util.concurrent.atomic.AtomicReference: boolean weakCompareAndSet(V,V)>
<java.util.concurrent.LinkedTransferQueue: E poll(long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.atomic.AtomicStampedReference: V getReference()>
<android.service.media.MediaBrowserService.Result: void sendResult(T)>
<org.apache.http.client.HttpClient: T execute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.client.ResponseHandler,org.apache.http.protocol.HttpContext)>
<android.util.Range: boolean contains(T)>
<android.util.Range: void <init>(T,T)>
<java.util.Optional: T orElseGet(java.util.function.Supplier)>
<java.util.concurrent.LinkedBlockingDeque: E pollFirst(long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.ConcurrentSkipListSet: E ceiling(E)>
<java.util.Set: boolean add(E)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: int getAndIncrement(T)>
<java.util.concurrent.LinkedBlockingDeque: E pollLast()>
<java.util.concurrent.CopyOnWriteArrayList: E get(int)>
<android.test.InstrumentationTestCase: T launchActivityWithIntent(java.lang.String,java.lang.Class,android.content.Intent)>
<java.util.concurrent.atomic.AtomicReferenceArray: E getAndAccumulate(int,E,java.util.function.BinaryOperator)>
<java.util.concurrent.LinkedBlockingDeque: E getFirst()>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: void set(T,int)>
<java.util.concurrent.ConcurrentSkipListMap: V replace(K,V)>
<java.lang.Class: A getAnnotation(java.lang.Class)>
<java.lang.Class: T cast(java.lang.Object)>
<java.util.concurrent.ForkJoinTask: void complete(V)>
<java.util.concurrent.BlockingDeque: void addFirst(E)>
<java.util.concurrent.ConcurrentHashMap: U searchValues(long,java.util.function.Function)>
<java.util.concurrent.ConcurrentNavigableMap: java.util.concurrent.ConcurrentNavigableMap subMap(K,boolean,K,boolean)>
<java.util.ArrayDeque: E peek()>
<java.util.concurrent.atomic.AtomicMarkableReference: boolean attemptMark(V,boolean)>
<org.apache.http.client.HttpClient: T execute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.client.ResponseHandler)>
<java.sql.SQLXML: T setResult(java.lang.Class)>
<java.util.concurrent.ForkJoinPool: T invoke(java.util.concurrent.ForkJoinTask)>
<java.util.concurrent.CompletableFuture: T get(long,java.util.concurrent.TimeUnit)>
<android.animation.ObjectAnimator: android.animation.ObjectAnimator ofInt(T,android.util.Property,android.util.Property,android.graphics.Path)>
<java.util.concurrent.AbstractExecutorService: T invokeAny(java.util.Collection)>
<java.util.concurrent.ConcurrentSkipListMap: V compute(K,java.util.function.BiFunction)>
<java.util.concurrent.DelayQueue: E poll(long,java.util.concurrent.TimeUnit)>
<java.util.Objects: T requireNonNull(T,java.util.function.Supplier)>
<java.util.Stack: E peek()>
<java.lang.reflect.AnnotatedElement: T getAnnotation(java.lang.Class)>
<java.util.function.Consumer: void accept(T)>
<java.util.AbstractCollection: boolean add(E)>
<java.util.NavigableSet: java.util.NavigableSet headSet(E,boolean)>
<java.util.PriorityQueue: E poll()>
<java.util.Hashtable: boolean replace(K,V,V)>
<java.util.concurrent.ConcurrentSkipListSet: java.util.NavigableSet subSet(E,E)>
<java.util.concurrent.LinkedBlockingQueue: E peek()>
<java.util.concurrent.atomic.AtomicReferenceFieldUpdater: V accumulateAndGet(T,V,java.util.function.BinaryOperator)>
<java.util.stream.LongStream: R collect(java.util.function.Supplier,java.util.function.ObjLongConsumer,java.util.function.BiConsumer)>
<java.util.concurrent.ConcurrentSkipListMap: java.util.concurrent.ConcurrentNavigableMap subMap(K,K)>
<java.util.concurrent.ConcurrentSkipListMap: boolean replace(K,V,V)>
<java.nio.channels.NetworkChannel: T getOption(java.net.SocketOption)>
<java.util.concurrent.ConcurrentSkipListMap: K lowerKey(K)>
<java.util.concurrent.ConcurrentNavigableMap: java.util.concurrent.ConcurrentNavigableMap tailMap(K,boolean)>
<android.webkit.ValueCallback: void onReceiveValue(T)>
<java.util.Hashtable: V get(java.lang.Object)>
<java.util.concurrent.LinkedBlockingDeque: E peek()>
<android.util.Range: android.util.Range intersect(T,T)>
<java.util.ArrayDeque: E pollLast()>
<android.os.RemoteCallbackList: E getBroadcastItem(int)>
<java.util.TreeMap: java.util.Map.Entry floorEntry(K)>
<java.util.ArrayDeque: E getLast()>
<android.icu.text.AlphabeticIndex.Record: V getData()>
<java.util.concurrent.CompletableFuture: java.util.concurrent.CompletableFuture completedFuture(U)>
<java.util.concurrent.atomic.AtomicReferenceArray: void set(int,E)>
<java.util.concurrent.ConcurrentLinkedDeque: E removeFirst()>
<java.util.HashMap: boolean replace(K,V,V)>
<java.util.Map.Entry: V setValue(V)>
<android.animation.BidirectionalTypeConverter: T convertBack(V)>
<java.util.Collections: java.util.Set singleton(E)>
<java.util.concurrent.CopyOnWriteArrayList: E remove(int)>
<java.util.NavigableSet: E ceiling(E)>
<java.lang.reflect.Method: A getAnnotation(java.lang.Class)>
<java.util.TreeMap: K higherKey(K)>
<android.util.LongSparseArray: E get(long)>
<java.util.LinkedList: E removeLast()>
<java.util.concurrent.LinkedBlockingDeque: void putFirst(E)>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: long getAndAdd(T,long)>
<java.util.concurrent.BlockingDeque: E take()>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: long accumulateAndGet(T,long,java.util.function.LongBinaryOperator)>
<java.util.TreeMap: boolean replace(K,V,V)>
<java.util.Queue: E poll()>
<java.util.Hashtable: V put(K,V)>
<android.animation.ObjectAnimator: android.animation.ObjectAnimator ofObject(T,android.util.Property,android.animation.TypeConverter,android.graphics.Path)>
<java.util.concurrent.ConcurrentSkipListSet: E pollLast()>
<java.util.concurrent.ConcurrentHashMap: U search(long,java.util.function.BiFunction)>
<java.util.Deque: E pop()>
<android.icu.util.Output: void <init>(T)>
<java.util.concurrent.DelayQueue: E peek()>
<java.util.concurrent.CompletionService: java.util.concurrent.Future submit(java.lang.Runnable,V)>
<java.util.concurrent.DelayQueue: boolean offer(E)>
<java.util.concurrent.CompletableFuture: T join()>
<android.util.SparseArray: void setValueAt(int,E)>
<java.util.Hashtable: V compute(K,java.util.function.BiFunction)>
<java.util.stream.Stream.Builder: void accept(T)>
<java.util.concurrent.BlockingDeque: void addLast(E)>
<java.util.NavigableMap: java.util.NavigableMap tailMap(K,boolean)>
<java.util.stream.Collectors: java.util.stream.Collector reducing(T,java.util.function.BinaryOperator)>
<android.os.RemoteCallbackList: boolean register(E,java.lang.Object)>
<java.util.Vector: E get(int)>
<java.util.function.ObjIntConsumer: void accept(T,int)>
<java.util.ArrayDeque: E removeFirst()>
<android.text.style.TtsSpan.Builder: C setStringArgument(java.lang.String,java.lang.String)>
<java.util.stream.BaseStream: S onClose(java.lang.Runnable)>
<java.util.concurrent.TransferQueue: boolean tryTransfer(E)>
<java.util.Deque: E peek()>
<java.util.concurrent.ConcurrentSkipListMap: java.util.concurrent.ConcurrentNavigableMap tailMap(K)>
<java.util.concurrent.BlockingDeque: E pollLast(long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.ConcurrentSkipListMap: V putIfAbsent(K,V)>
<java.util.TreeMap: java.util.NavigableMap subMap(K,boolean,K,boolean)>
<java.util.concurrent.FutureTask: V get(long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: int get(T)>
<java.lang.Package: A getDeclaredAnnotation(java.lang.Class)>
<java.util.concurrent.ForkJoinTask: java.util.concurrent.ForkJoinTask adapt(java.lang.Runnable,T)>
<java.util.concurrent.LinkedBlockingDeque: boolean offerFirst(E,long,java.util.concurrent.TimeUnit)>
<java.util.LinkedList: boolean offerLast(E)>
<java.util.AbstractQueue: E remove()>
<java.util.concurrent.LinkedBlockingDeque: E take()>
<android.widget.ArrayAdapter: T getItem(int)>
<java.util.NavigableMap: java.util.NavigableMap headMap(K,boolean)>
<java.util.SortedMap: java.util.SortedMap tailMap(K)>
<java.util.TreeMap: java.util.Map.Entry ceilingEntry(K)>
<org.apache.http.client.HttpClient: T execute(org.apache.http.client.methods.HttpUriRequest,org.apache.http.client.ResponseHandler,org.apache.http.protocol.HttpContext)>
<java.util.concurrent.RecursiveTask: V compute()>
<java.util.concurrent.DelayQueue: E take()>
<android.accounts.AccountManagerFuture: V getResult()>
<android.test.ApplicationTestCase: T getApplication()>
<java.util.function.ToIntBiFunction: int applyAsInt(T,U)>
<android.animation.ObjectAnimator: android.animation.ObjectAnimator ofMultiFloat(java.lang.Object,java.lang.String,android.animation.TypeConverter,android.animation.TypeEvaluator,T...)>
<java.util.concurrent.LinkedTransferQueue: boolean tryTransfer(E)>
<java.util.Dictionary: V put(K,V)>
<java.util.NavigableSet: E floor(E)>
<java.util.NavigableMap: java.util.SortedMap tailMap(K)>
<java.util.AbstractMap.SimpleImmutableEntry: V getValue()>
<java.util.EnumSet: java.util.EnumSet range(E,E)>
<java.util.concurrent.CompletableFuture: T getNow(T)>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: long getAndDecrement(T)>
<java.util.ArrayDeque: boolean offerFirst(E)>
<java.security.AccessController: T doPrivilegedWithCombiner(java.security.PrivilegedAction)>
<java.util.concurrent.CopyOnWriteArrayList: boolean add(E)>
<java.util.concurrent.BlockingDeque: boolean add(E)>
<java.util.concurrent.ConcurrentHashMap: boolean replace(K,V,V)>
<android.util.ArraySet: E removeAt(int)>
<java.util.Map.Entry: K getKey()>
<java.util.concurrent.ConcurrentSkipListMap: K floorKey(K)>
<java.util.concurrent.atomic.AtomicReferenceArray: E getAndUpdate(int,java.util.function.UnaryOperator)>
<java.util.Comparator: int compare(T,T)>
<java.util.Map: V getOrDefault(java.lang.Object,V)>
<android.database.Observable: void registerObserver(T)>
<java.util.NavigableSet: E higher(E)>
<java.util.concurrent.LinkedBlockingDeque: E removeFirst()>
<java.util.LinkedList: E getLast()>
<java.util.concurrent.ConcurrentSkipListSet: java.util.NavigableSet subSet(E,boolean,E,boolean)>
<java.util.concurrent.Exchanger: V exchange(V)>
<android.util.LongSparseArray: void put(long,E)>
<java.util.concurrent.ArrayBlockingQueue: boolean offer(E,long,java.util.concurrent.TimeUnit)>
<java.util.ArrayDeque: E pollFirst()>
<java.util.concurrent.LinkedTransferQueue: boolean tryTransfer(E,long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.atomic.AtomicReferenceFieldUpdater: boolean compareAndSet(T,V,V)>
<java.util.Deque: E getLast()>
<java.util.TreeSet: E lower(E)>
<android.animation.ObjectAnimator: android.animation.ObjectAnimator ofObject(T,android.util.Property,android.animation.TypeEvaluator,V...)>
<java.util.concurrent.atomic.AtomicReference: void <init>(V)>
<java.util.concurrent.atomic.AtomicReferenceFieldUpdater: void set(T,V)>
<android.service.carrier.CarrierMessagingService.ResultCallback: void onReceiveResult(T)>
<java.util.ArrayDeque: E peekLast()>
<java.util.concurrent.LinkedBlockingQueue: boolean offer(E)>
<java.util.Collections: int binarySearch(java.util.List,T,java.util.Comparator)>
<java.util.concurrent.ConcurrentLinkedDeque: boolean offer(E)>
<java.util.Queue: boolean offer(E)>
<java.util.Collections: T max(java.util.Collection,java.util.Comparator)>
<android.widget.ArrayAdapter: void addAll(T...)>
<java.util.List: E get(int)>
<java.util.concurrent.BlockingDeque: boolean offerFirst(E)>
<java.util.Vector: E elementAt(int)>
<java.util.concurrent.LinkedBlockingDeque: boolean offerFirst(E)>
<android.hardware.camera2.CaptureRequest.Builder: T get(android.hardware.camera2.CaptureRequest.Key)>
<java.util.function.Function: R apply(T)>
<java.util.Deque: E removeLast()>
<java.util.concurrent.atomic.AtomicReference: V accumulateAndGet(V,java.util.function.BinaryOperator)>
<java.util.stream.IntStream: R collect(java.util.function.Supplier,java.util.function.ObjIntConsumer,java.util.function.BiConsumer)>
<java.util.NavigableMap: K ceilingKey(K)>
<java.util.ListIterator: void add(E)>
<java.security.AccessController: T doPrivileged(java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>
<java.util.concurrent.atomic.AtomicReference: V updateAndGet(java.util.function.UnaryOperator)>
<java.util.EnumSet: java.util.EnumSet of(E,E...)>
<java.util.concurrent.atomic.AtomicReferenceArray: void lazySet(int,E)>
<java.util.NavigableMap: K floorKey(K)>
<java.util.concurrent.SynchronousQueue: E peek()>
<android.util.Range: T getUpper()>
<javax.security.auth.Subject: T doAs(javax.security.auth.Subject,java.security.PrivilegedAction)>
<android.graphics.drawable.AnimatedStateListDrawable: void addTransition(int,int,T,boolean)>
<java.util.LinkedList: E element()>
<java.util.concurrent.ExecutorService: java.util.concurrent.Future submit(java.lang.Runnable,T)>
<java.util.function.BiConsumer: void accept(T,U)>
<java.util.concurrent.TransferQueue: void transfer(E)>
<java.util.concurrent.ConcurrentSkipListSet: E higher(E)>
<java.util.TreeSet: java.util.NavigableSet tailSet(E,boolean)>
<java.util.concurrent.atomic.AtomicStampedReference: void <init>(V,int)>
<java.util.concurrent.LinkedBlockingDeque: void putLast(E)>
<java.util.function.ToIntFunction: int applyAsInt(T)>
<java.util.concurrent.ConcurrentHashMap: V getOrDefault(java.lang.Object,V)>
<java.util.TreeSet: E first()>
<java.lang.reflect.Constructor: A getAnnotation(java.lang.Class)>
<javax.security.auth.Subject: T doAsPrivileged(javax.security.auth.Subject,java.security.PrivilegedAction,java.security.AccessControlContext)>
<java.util.concurrent.atomic.AtomicReference: void set(V)>
<java.util.concurrent.LinkedBlockingQueue: void put(E)>
<java.util.NavigableSet: java.util.SortedSet tailSet(E)>
<java.util.concurrent.ExecutorService: T invokeAny(java.util.Collection,long,java.util.concurrent.TimeUnit)>
<java.util.Arrays: int binarySearch(T[],int,int,T,java.util.Comparator)>
<java.security.PrivilegedExceptionAction: T run()>
<android.text.style.TtsSpan.SemioticClassBuilder: C setGender(java.lang.String)>
<java.lang.ref.Reference: T get()>
<java.util.NavigableMap: java.util.Map.Entry lowerEntry(K)>
<java.util.concurrent.atomic.AtomicStampedReference: boolean compareAndSet(V,V,int,int)>
<android.test.ServiceTestCase: T getService()>
<java.util.Queue: E peek()>
<java.util.Deque: boolean offerFirst(E)>
<java.util.concurrent.ConcurrentSkipListSet: java.util.NavigableSet tailSet(E,boolean)>
<java.util.concurrent.BlockingQueue: void put(E)>
<java.util.concurrent.atomic.AtomicReferenceArray: E getAndSet(int,E)>
<java.util.SortedMap: K lastKey()>
<java.util.concurrent.ConcurrentSkipListMap: K higherKey(K)>
<java.util.concurrent.atomic.AtomicReferenceFieldUpdater: V getAndAccumulate(T,V,java.util.function.BinaryOperator)>
<java.util.concurrent.LinkedTransferQueue: void put(E)>
<java.util.SortedSet: java.util.SortedSet subSet(E,E)>
<java.util.concurrent.ConcurrentHashMap: java.util.concurrent.ConcurrentHashMap.KeySetView keySet(V)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: boolean weakCompareAndSet(T,int,int)>
<java.util.concurrent.ConcurrentLinkedDeque: void push(E)>
<java.util.concurrent.ConcurrentLinkedQueue: E poll()>
<android.content.Loader: java.lang.String dataToString(D)>
<java.util.concurrent.atomic.AtomicMarkableReference: boolean compareAndSet(V,V,boolean,boolean)>
<android.icu.text.UnicodeSet: android.icu.text.UnicodeSet addAll(T...)>
<java.util.Map: V computeIfPresent(K,java.util.function.BiFunction)>
<java.util.concurrent.ForkJoinTask: V invoke()>
<java.util.concurrent.ConcurrentMap: V replace(K,V)>
<java.util.TreeMap: java.util.NavigableMap tailMap(K,boolean)>
<java.util.concurrent.TransferQueue: boolean tryTransfer(E,long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.Future: V get()>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: long decrementAndGet(T)>
<java.security.KeyFactory: T getKeySpec(java.security.Key,java.lang.Class)>
<java.util.TreeMap: V replace(K,V)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: int getAndAdd(T,int)>
<java.util.concurrent.ConcurrentLinkedDeque: E getLast()>
<java.util.TreeSet: java.util.SortedSet subSet(E,E)>
<java.util.Map: V compute(K,java.util.function.BiFunction)>
<java.util.TreeSet: java.util.NavigableSet headSet(E,boolean)>
<java.util.Collections: T min(java.util.Collection,java.util.Comparator)>
<java.util.NavigableSet: E lower(E)>
<java.util.AbstractMap.SimpleImmutableEntry: V setValue(V)>
<java.util.concurrent.atomic.AtomicReferenceArray: E get(int)>
<java.util.concurrent.LinkedBlockingDeque: E pop()>
<java.util.SortedMap: K firstKey()>
<java.util.concurrent.PriorityBlockingQueue: E poll()>
<java.util.concurrent.AbstractExecutorService: T invokeAny(java.util.Collection,long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.ConcurrentLinkedDeque: E peekLast()>
<java.util.TreeSet: E pollFirst()>
<java.util.stream.Stream.Builder: java.util.stream.Stream.Builder add(T)>
<java.util.NavigableMap: K lowerKey(K)>
<java.util.SortedSet: java.util.SortedSet tailSet(E)>
<java.lang.ThreadLocal: void set(T)>
<android.util.LruCache: void entryRemoved(boolean,K,V,V)>
<java.security.PrivilegedAction: T run()>
<java.util.concurrent.BlockingDeque: E remove()>
<java.lang.Comparable: int compareTo(T)>
<java.util.concurrent.ExecutorService: T invokeAny(java.util.Collection)>
<android.util.ArrayMap: K keyAt(int)>
<android.os.Parcelable.Creator: T createFromParcel(android.os.Parcel)>
<java.security.AlgorithmParametersSpi: T engineGetParameterSpec(java.lang.Class)>
<java.util.List: void add(int,E)>
<java.util.AbstractQueue: E element()>
<java.util.Optional: java.util.Optional ofNullable(T)>
<java.util.concurrent.atomic.AtomicReferenceFieldUpdater: boolean weakCompareAndSet(T,V,V)>
<android.hardware.camera2.CaptureResult: T get(android.hardware.camera2.CaptureResult.Key)>
<java.util.concurrent.BlockingDeque: boolean offer(E,long,java.util.concurrent.TimeUnit)>
<android.util.Range: T getLower()>
<android.test.ProviderTestCase: T getProvider()>
<android.widget.ArrayAdapter: void add(T)>
<android.util.ArrayMap: V valueAt(int)>
<java.util.concurrent.ConcurrentHashMap: V merge(K,V,java.util.function.BiFunction)>
<android.util.SparseArray: void put(int,E)>
<java.util.ArrayDeque: E element()>
<java.util.concurrent.LinkedBlockingDeque: E peekFirst()>
<java.util.concurrent.ConcurrentSkipListMap: java.util.concurrent.ConcurrentNavigableMap headMap(K,boolean)>
<java.util.Objects: T requireNonNull(T,java.lang.String)>
<java.util.concurrent.ConcurrentNavigableMap: java.util.concurrent.ConcurrentNavigableMap headMap(K)>
<java.util.TreeMap: java.util.NavigableMap headMap(K,boolean)>
<java.util.concurrent.ArrayBlockingQueue: boolean offer(E)>
<android.content.Intent: T getParcelableExtra(java.lang.String)>
<java.util.EnumSet: java.util.EnumSet of(E,E,E,E,E)>
<java.util.AbstractMap: V remove(java.lang.Object)>
<java.util.concurrent.ConcurrentHashMap: U reduceEntries(long,java.util.function.Function,java.util.function.BiFunction)>
<android.util.IntProperty: void set(T,java.lang.Integer)>
<java.util.Deque: void push(E)>
<java.util.concurrent.ConcurrentLinkedDeque: E poll()>
<java.util.function.DoubleFunction: R apply(double)>
<android.util.SparseArray: void append(int,E)>
<java.util.concurrent.BlockingQueue: boolean offer(E,long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: long addAndGet(T,long)>
<java.util.List: boolean add(E)>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: void set(T,long)>
<java.util.concurrent.SynchronousQueue: void put(E)>
<android.net.http.AndroidHttpClient: T execute(org.apache.http.client.methods.HttpUriRequest,org.apache.http.client.ResponseHandler)>
<java.util.LinkedList: void push(E)>
<java.util.concurrent.ConcurrentSkipListSet: E floor(E)>
<java.util.NavigableMap: java.util.SortedMap subMap(K,K)>
<java.util.concurrent.BlockingDeque: boolean offerLast(E)>
<java.util.concurrent.ConcurrentMap: boolean replace(K,V,V)>
<java.util.concurrent.Exchanger: V exchange(V,long,java.util.concurrent.TimeUnit)>
<android.widget.ArrayAdapter: int getPosition(T)>
<android.animation.ObjectAnimator: android.animation.ObjectAnimator ofMultiInt(java.lang.Object,java.lang.String,android.animation.TypeConverter,android.animation.TypeEvaluator,T...)>
<android.animation.TypeConverter: V convert(T)>
<java.util.concurrent.ConcurrentHashMap.KeySetView: boolean add(K)>
<java.util.concurrent.atomic.AtomicReferenceFieldUpdater: void lazySet(T,V)>
<java.util.concurrent.CopyOnWriteArrayList: void add(int,E)>
<java.util.concurrent.Callable: V call()>
<java.util.Hashtable: V computeIfAbsent(K,java.util.function.Function)>
<java.util.concurrent.LinkedBlockingQueue: E take()>
<android.test.ActivityInstrumentationTestCase: T getActivity()>
<java.util.PriorityQueue: boolean offer(E)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: int addAndGet(T,int)>
<java.util.concurrent.BlockingDeque: E pollFirst(long,java.util.concurrent.TimeUnit)>
<android.os.Parcel: T readParcelable(java.lang.ClassLoader)>
<android.text.style.TtsSpan.SemioticClassBuilder: C setMultiplicity(java.lang.String)>
<java.util.LinkedList: boolean offerFirst(E)>
<java.util.stream.Collectors: java.util.stream.Collector reducing(U,java.util.function.Function,java.util.function.BinaryOperator)>
<java.util.concurrent.ConcurrentSkipListSet: java.util.NavigableSet headSet(E)>
<java.util.concurrent.LinkedTransferQueue: E peek()>
<android.animation.PropertyValuesHolder: android.animation.PropertyValuesHolder ofObject(android.util.Property,android.animation.TypeEvaluator,V...)>
<java.util.AbstractMap.SimpleEntry: K getKey()>
<android.net.http.AndroidHttpClient: T execute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.client.ResponseHandler,org.apache.http.protocol.HttpContext)>
<java.util.concurrent.ConcurrentHashMap: K reduceKeys(long,java.util.function.BiFunction)>
<java.util.concurrent.LinkedTransferQueue: boolean offer(E)>
<java.util.concurrent.ConcurrentLinkedDeque: E removeLast()>
<java.util.PriorityQueue: E peek()>
<java.util.Map: V remove(java.lang.Object)>
<java.util.concurrent.atomic.AtomicMarkableReference: V get(boolean[])>
<java.util.LinkedList: E pop()>
<java.util.NavigableMap: java.util.Map.Entry ceilingEntry(K)>
<java.lang.ref.WeakReference: void <init>(T)>
<android.icu.text.UnicodeSet: T addAllTo(T)>
<java.util.concurrent.LinkedTransferQueue: E poll()>
<java.util.concurrent.ConcurrentHashMap: V computeIfPresent(K,java.util.function.BiFunction)>
<java.nio.channels.SocketChannel: java.nio.channels.SocketChannel setOption(java.net.SocketOption,T)>
<java.util.concurrent.ConcurrentSkipListMap: java.util.concurrent.ConcurrentNavigableMap tailMap(K,boolean)>
<java.util.TreeSet: java.util.SortedSet headSet(E)>
<android.animation.ObjectAnimator: android.animation.ObjectAnimator ofFloat(T,android.util.Property,android.util.Property,android.graphics.Path)>
<java.util.ListIterator: E next()>
<android.test.ProviderTestCase2: T getProvider()>
<java.util.concurrent.atomic.AtomicReference: boolean compareAndSet(V,V)>
<android.app.FragmentHostCallback: E onGetHost()>
<java.util.AbstractMap: V get(java.lang.Object)>
<java.util.concurrent.ConcurrentSkipListMap: java.util.Map.Entry higherEntry(K)>
<java.util.concurrent.BlockingDeque: boolean offer(E)>
<java.util.concurrent.AbstractExecutorService: java.util.concurrent.RunnableFuture newTaskFor(java.lang.Runnable,T)>
<java.util.Stack: E push(E)>
<java.util.concurrent.SynchronousQueue: E poll(long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.ConcurrentSkipListSet: java.util.NavigableSet headSet(E,boolean)>
<java.util.concurrent.ConcurrentSkipListSet: E first()>
<java.util.concurrent.ConcurrentHashMap: U searchKeys(long,java.util.function.Function)>
<java.util.NavigableMap: java.util.SortedMap headMap(K)>
<java.util.ArrayDeque: boolean offerLast(E)>
<java.util.concurrent.BlockingQueue: boolean add(E)>
<java.util.ArrayDeque: E getFirst()>
<java.util.AbstractMap: V put(K,V)>
<java.lang.ThreadLocal: T initialValue()>
<android.util.SparseArray: int indexOfValue(E)>
<java.util.Vector: E firstElement()>
<java.util.function.IntFunction: R apply(int)>
<android.os.Parcel: void writeTypedObject(T,int)>
<android.test.ActivityInstrumentationTestCase2: T getActivity()>
<java.util.Queue: boolean add(E)>
<java.util.function.Supplier: T get()>
<java.util.EnumSet: java.util.EnumSet of(E,E)>
<java.util.NavigableSet: java.util.SortedSet subSet(E,E)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: int updateAndGet(T,java.util.function.IntUnaryOperator)>
<java.util.Collections: int binarySearch(java.util.List,T)>
<java.util.concurrent.BlockingDeque: boolean offerLast(E,long,java.util.concurrent.TimeUnit)>
<java.util.Dictionary: V remove(java.lang.Object)>
<android.animation.ObjectAnimator: android.animation.ObjectAnimator ofInt(T,android.util.Property,int...)>
<java.util.ArrayList: E get(int)>
<java.util.concurrent.ConcurrentSkipListMap: java.util.Map.Entry ceilingEntry(K)>
<java.util.concurrent.BlockingDeque: void putFirst(E)>
<java.util.function.ToDoubleBiFunction: double applyAsDouble(T,U)>
<java.util.concurrent.ConcurrentSkipListSet: E last()>
<android.util.LongSparseArray: void setValueAt(int,E)>
<java.util.concurrent.ConcurrentLinkedQueue: E peek()>
<android.util.LruCache: V put(K,V)>
<java.util.ArrayDeque: E poll()>
<java.util.concurrent.FutureTask: void <init>(java.lang.Runnable,V)>
<java.util.concurrent.ConcurrentSkipListSet: E lower(E)>
<java.util.concurrent.PriorityBlockingQueue: E peek()>
<java.util.TreeSet: java.util.SortedSet tailSet(E)>
<android.util.Range: android.util.Range extend(T,T)>
<java.util.Arrays: java.util.List asList(T...)>
<java.util.concurrent.LinkedTransferQueue: boolean offer(E,long,java.util.concurrent.TimeUnit)>
<java.util.LinkedList: E poll()>
<java.util.concurrent.BlockingDeque: E takeFirst()>
<java.util.concurrent.ConcurrentHashMap: V reduceValues(long,java.util.function.BiFunction)>
<java.util.function.ToLongBiFunction: long applyAsLong(T,U)>
<android.util.FloatProperty: void setValue(T,float)>
<java.util.concurrent.atomic.AtomicStampedReference: void set(V,int)>
<java.util.concurrent.CompletableFuture: void obtrudeValue(T)>
<java.util.concurrent.ConcurrentSkipListMap: java.util.concurrent.ConcurrentNavigableMap subMap(K,boolean,K,boolean)>
<java.util.concurrent.ConcurrentSkipListMap: java.util.Map.Entry lowerEntry(K)>
<java.util.concurrent.LinkedBlockingDeque: E poll()>
<android.content.Loader.OnLoadCompleteListener: void onLoadComplete(android.content.Loader,D)>
<java.util.concurrent.LinkedBlockingDeque: void push(E)>
<java.util.ListIterator: E previous()>
<java.util.concurrent.ConcurrentSkipListMap: V computeIfPresent(K,java.util.function.BiFunction)>
<java.util.NavigableMap: java.util.NavigableMap subMap(K,boolean,K,boolean)>
<java.util.concurrent.DelayQueue: E poll()>
<android.test.ActivityUnitTestCase: T getActivity()>
<java.util.concurrent.ConcurrentHashMap: U reduce(long,java.util.function.BiFunction,java.util.function.BiFunction)>
<java.util.concurrent.ConcurrentSkipListMap: V computeIfAbsent(K,java.util.function.Function)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: int decrementAndGet(T)>
<java.util.concurrent.BlockingDeque: void push(E)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: int getAndSet(T,int)>
<java.util.Deque: E remove()>
<java.util.EventListenerProxy: void <init>(T)>
<android.text.style.TtsSpan.Builder: C setIntArgument(java.lang.String,int)>
<org.apache.http.impl.client.AbstractHttpClient: T execute(org.apache.http.client.methods.HttpUriRequest,org.apache.http.client.ResponseHandler,org.apache.http.protocol.HttpContext)>
<android.accounts.AccountManagerFuture: V getResult(long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.ConcurrentHashMap: V computeIfAbsent(K,java.util.function.Function)>
<java.util.stream.BaseStream: S unordered()>
<java.sql.SQLXML: T getSource(java.lang.Class)>
<android.animation.ObjectAnimator: android.animation.ObjectAnimator ofFloat(T,android.util.Property,float...)>
<java.util.concurrent.ConcurrentLinkedDeque: E pollFirst()>
<java.util.concurrent.ForkJoinTask: void setRawResult(V)>
<java.util.concurrent.atomic.AtomicReference: void lazySet(V)>
<android.util.LruCache: V create(K)>
<java.sql.Wrapper: T unwrap(java.lang.Class)>
<java.lang.reflect.Field: A getAnnotation(java.lang.Class)>
<java.util.concurrent.RecursiveTask: void setRawResult(V)>
<java.util.concurrent.BlockingDeque: boolean offerFirst(E,long,java.util.concurrent.TimeUnit)>
<java.util.Hashtable: V getOrDefault(java.lang.Object,V)>
<android.animation.ObjectAnimator: android.animation.ObjectAnimator ofObject(T,android.util.Property,android.animation.TypeConverter,android.animation.TypeEvaluator,V...)>
<android.content.AsyncTaskLoader: D onLoadInBackground()>
<java.util.stream.Stream: java.util.stream.Stream iterate(T,java.util.function.UnaryOperator)>
<java.util.Deque: E element()>
<org.apache.http.impl.client.AbstractHttpClient: T execute(org.apache.http.client.methods.HttpUriRequest,org.apache.http.client.ResponseHandler)>
<java.lang.Class: T newInstance()>
<java.util.Map: V replace(K,V)>
<java.util.Deque: void addLast(E)>
<android.content.Loader: void deliverResult(D)>
<java.util.TreeMap: K firstKey()>
<java.util.concurrent.ConcurrentNavigableMap: java.util.concurrent.ConcurrentNavigableMap tailMap(K)>
<java.util.Collections: T max(java.util.Collection)>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: long getAndAccumulate(T,long,java.util.function.LongBinaryOperator)>
<java.util.concurrent.ConcurrentNavigableMap: java.util.concurrent.ConcurrentNavigableMap subMap(K,K)>
<java.util.function.Predicate: boolean test(T)>
<java.lang.ref.WeakReference: void <init>(T,java.lang.ref.ReferenceQueue)>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: long get(T)>
<java.util.Deque: boolean offer(E)>
<android.util.LruCache: int sizeOf(K,V)>
<java.util.concurrent.atomic.AtomicReferenceFieldUpdater: V updateAndGet(T,java.util.function.UnaryOperator)>
<java.util.function.ObjLongConsumer: void accept(T,long)>
<java.util.concurrent.ConcurrentSkipListSet: java.util.NavigableSet tailSet(E)>
<java.util.AbstractList: void add(int,E)>
<java.security.AccessController: T doPrivileged(java.security.PrivilegedExceptionAction)>
<java.util.Optional: T orElseThrow(java.util.function.Supplier)>
<java.util.NavigableMap: java.util.Map.Entry floorEntry(K)>
<java.util.Optional: T orElse(T)>
<java.util.Hashtable: V merge(K,V,java.util.function.BiFunction)>
<java.lang.reflect.AccessibleObject: T getAnnotation(java.lang.Class)>
<android.widget.AdapterView: void setAdapter(T)>
<java.util.ArrayDeque: E remove()>
<java.util.concurrent.CountedCompleter: void setRawResult(T)>
<android.os.Parcel: T readTypedObject(android.os.Parcelable.Creator)>
<java.util.TreeMap: java.util.SortedMap tailMap(K)>
<java.util.SortedMap: java.util.SortedMap subMap(K,K)>
<java.util.EnumSet: java.util.EnumSet of(E,E,E,E)>
<java.util.concurrent.ExecutorCompletionService: java.util.concurrent.Future submit(java.lang.Runnable,V)>
<android.test.RenamingDelegatingContext: T providerWithRenamedContext(java.lang.Class,android.content.Context,java.lang.String)>
<android.widget.AdapterView: T getAdapter()>
<android.test.LoaderTestCase: T getLoaderResultSynchronously(android.content.Loader)>
<android.test.SingleLaunchActivityTestCase: T getActivity()>
<android.text.style.TtsSpan.SemioticClassBuilder: C setAnimacy(java.lang.String)>
<java.util.concurrent.atomic.AtomicStampedReference: boolean attemptStamp(V,int)>
<java.util.concurrent.LinkedBlockingQueue: E poll()>
<java.util.concurrent.LinkedBlockingDeque: boolean offer(E,long,java.util.concurrent.TimeUnit)>
<java.util.LinkedList: void addLast(E)>
<android.widget.ArrayAdapter: void insert(T,int)>
<java.util.List: E set(int,E)>
<java.util.NavigableMap: java.util.Map.Entry higherEntry(K)>
<java.util.AbstractSequentialList: E get(int)>
<java.util.TreeMap: K floorKey(K)>
<android.util.LongSparseArray: int indexOfValue(E)>
<java.util.concurrent.ConcurrentHashMap: U searchEntries(long,java.util.function.Function)>
<java.util.concurrent.ArrayBlockingQueue: E peek()>
<java.util.concurrent.ConcurrentSkipListMap: V merge(K,V,java.util.function.BiFunction)>
<java.util.Objects: T requireNonNull(T)>
<java.util.Collections: java.util.List singletonList(E)>
<java.util.concurrent.BlockingQueue: boolean offer(E)>
<java.util.ArrayDeque: void addFirst(E)>
<java.util.concurrent.BlockingDeque: void put(E)>
<android.util.Property: void set(T,V)>
<android.os.RemoteCallbackList: boolean register(E)>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: boolean compareAndSet(T,long,long)>
<java.util.AbstractMap.SimpleEntry: V getValue()>
<java.util.stream.BaseStream: S sequential()>
<java.util.concurrent.atomic.AtomicReferenceArray: E updateAndGet(int,java.util.function.UnaryOperator)>
<java.util.Vector: void setElementAt(E,int)>
<java.util.concurrent.LinkedBlockingQueue: boolean offer(E,long,java.util.concurrent.TimeUnit)>
<java.util.LinkedList: E peekFirst()>
<java.util.ArrayDeque: void push(E)>
<java.util.Map: V get(java.lang.Object)>
<android.test.suitebuilder.TestMethod: T getAnnotation(java.lang.Class)>
<android.util.ArraySet: E valueAt(int)>
<java.util.concurrent.atomic.AtomicReferenceFieldUpdater: V getAndUpdate(T,java.util.function.UnaryOperator)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: int getAndDecrement(T)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: int getAndAccumulate(T,int,java.util.function.IntBinaryOperator)>
<java.util.TreeMap: K lowerKey(K)>
<java.util.concurrent.ArrayBlockingQueue: void put(E)>
<android.util.SparseArray: E get(int,E)>
<javax.security.auth.Subject: T doAsPrivileged(javax.security.auth.Subject,java.security.PrivilegedExceptionAction,java.security.AccessControlContext)>
<java.security.AccessController: T doPrivilegedWithCombiner(java.security.PrivilegedExceptionAction)>
<java.util.concurrent.BlockingDeque: void putLast(E)>
<java.util.LinkedList: void addFirst(E)>
<java.util.concurrent.atomic.AtomicReferenceFieldUpdater: V getAndSet(T,V)>
<java.util.Collections: void fill(java.util.List,T)>
<android.util.FloatProperty: void set(T,java.lang.Float)>
<android.content.Context: T getSystemService(java.lang.Class)>
<android.icu.util.Freezable: T cloneAsThawed()>
<java.util.concurrent.FutureTask: V get()>
<java.util.EnumSet: java.util.EnumSet of(E,E,E)>
<java.util.Enumeration: E nextElement()>
<java.util.SortedSet: E last()>
<java.util.NavigableSet: java.util.SortedSet headSet(E)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: int accumulateAndGet(T,int,java.util.function.IntBinaryOperator)>
<java.util.ListIterator: void set(E)>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: long getAndSet(T,long)>
<java.lang.ref.PhantomReference: void <init>(T,java.lang.ref.ReferenceQueue)>
<java.util.Deque: E peekFirst()>
<java.util.concurrent.ConcurrentSkipListMap: K ceilingKey(K)>
<java.util.Objects: int compare(T,T,java.util.Comparator)>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: long updateAndGet(T,java.util.function.LongUnaryOperator)>
<android.animation.PropertyValuesHolder: android.animation.PropertyValuesHolder ofMultiInt(java.lang.String,android.animation.TypeConverter,android.animation.TypeEvaluator,V...)>
<java.util.concurrent.ConcurrentLinkedDeque: E pollLast()>
<java.lang.ThreadLocal: T get()>
<java.lang.reflect.Constructor: T newInstance(java.lang.Object...)>
<java.util.EnumSet: java.util.EnumSet of(E)>
<java.util.concurrent.DelayQueue: boolean offer(E,long,java.util.concurrent.TimeUnit)>
<java.util.Deque: void addFirst(E)>
<java.util.TreeMap: java.util.SortedMap subMap(K,K)>
<java.util.Arrays: int binarySearch(T[],T,java.util.Comparator)>
<java.util.concurrent.SynchronousQueue: E take()>
<android.animation.TypeEvaluator: T evaluate(float,T,T)>
<java.util.concurrent.atomic.AtomicReferenceArray: boolean weakCompareAndSet(int,E,E)>
<java.util.concurrent.ArrayBlockingQueue: E take()>
<java.nio.channels.NetworkChannel: java.nio.channels.NetworkChannel setOption(java.net.SocketOption,T)>
<java.util.concurrent.ConcurrentHashMap: V compute(K,java.util.function.BiFunction)>
<android.text.style.TtsSpan.Builder: C setLongArgument(java.lang.String,long)>
<android.util.Range: T clamp(T)>
<android.net.http.AndroidHttpClient: T execute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.client.ResponseHandler)>
<android.util.Pair: android.util.Pair create(A,B)>
<java.util.concurrent.atomic.AtomicReference: V getAndAccumulate(V,java.util.function.BinaryOperator)>
<java.util.Map: boolean replace(K,V,V)>
<java.util.concurrent.BlockingDeque: E poll()>
<java.nio.channels.DatagramChannel: java.nio.channels.DatagramChannel setOption(java.net.SocketOption,T)>
<android.content.AsyncTaskLoader: D loadInBackground()>
<java.util.Collections: boolean addAll(java.util.Collection,T...)>
<java.util.concurrent.LinkedTransferQueue: E take()>
<android.util.ArrayMap: V removeAt(int)>
<java.util.concurrent.FutureTask: void set(V)>
<java.util.stream.Stream: U reduce(U,java.util.function.BiFunction,java.util.function.BinaryOperator)>
<java.util.concurrent.CountedCompleter: void complete(T)>
<java.lang.ref.SoftReference: void <init>(T,java.lang.ref.ReferenceQueue)>
<java.util.concurrent.SynchronousQueue: boolean offer(E)>
<java.util.AbstractMap.SimpleImmutableEntry: void <init>(K,V)>
<org.apache.http.client.HttpClient: T execute(org.apache.http.client.methods.HttpUriRequest,org.apache.http.client.ResponseHandler)>
<java.util.concurrent.LinkedTransferQueue: void transfer(E)>
<java.util.function.ToDoubleFunction: double applyAsDouble(T)>
<java.util.concurrent.LinkedBlockingDeque: boolean offerLast(E)>
<java.util.concurrent.LinkedBlockingDeque: void addLast(E)>
<java.util.concurrent.PriorityBlockingQueue: E poll(long,java.util.concurrent.TimeUnit)>
<java.util.ArrayDeque: E pop()>
<java.util.LinkedList: boolean offer(E)>
<android.database.Observable: void unregisterObserver(T)>
<java.util.Hashtable: V remove(java.lang.Object)>
<android.hardware.camera2.CaptureRequest: T get(android.hardware.camera2.CaptureRequest.Key)>
<java.util.concurrent.LinkedBlockingDeque: void addFirst(E)>
<java.util.SortedSet: E first()>
<java.util.concurrent.LinkedBlockingDeque: boolean offerLast(E,long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.ConcurrentSkipListMap: K lastKey()>
<java.util.Deque: E getFirst()>
<java.util.Deque: E removeFirst()>
<android.icu.text.AlphabeticIndex: android.icu.text.AlphabeticIndex addRecord(java.lang.CharSequence,V)>
<java.util.concurrent.CountedCompleter: T getRawResult()>
<java.util.concurrent.ConcurrentHashMap: U reduceKeys(long,java.util.function.Function,java.util.function.BiFunction)>
<org.apache.http.impl.client.AbstractHttpClient: T execute(org.apache.http.HttpHost,org.apache.http.HttpRequest,org.apache.http.client.ResponseHandler,org.apache.http.protocol.HttpContext)>
<java.util.Collections: java.util.List nCopies(int,T)>
<java.util.concurrent.LinkedBlockingDeque: E pollLast(long,java.util.concurrent.TimeUnit)>
<android.net.http.AndroidHttpClient: T execute(org.apache.http.client.methods.HttpUriRequest,org.apache.http.client.ResponseHandler,org.apache.http.protocol.HttpContext)>
<java.util.LinkedList: E getFirst()>
<java.util.concurrent.LinkedBlockingDeque: void put(E)>
<java.util.TreeMap: K lastKey()>
<java.util.concurrent.ConcurrentLinkedDeque: boolean offerFirst(E)>
<java.util.TreeSet: E higher(E)>
<java.util.Stack: E pop()>
<java.util.function.ToLongFunction: long applyAsLong(T)>
<java.util.Deque: boolean offerLast(E)>
<java.util.concurrent.ForkJoinTask: V getRawResult()>
<android.util.ArrayMap: V put(K,V)>
<java.util.concurrent.SynchronousQueue: boolean offer(E,long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.ConcurrentLinkedDeque: E element()>
<java.util.TreeSet: E last()>
<android.content.ContentProvider.PipeDataWriter: void writeDataToPipe(android.os.ParcelFileDescriptor,android.net.Uri,java.lang.String,android.os.Bundle,T)>
<java.security.KeyFactorySpi: T engineGetKeySpec(java.security.Key,java.lang.Class)>
<java.util.concurrent.ConcurrentHashMap: U reduceValues(long,java.util.function.Function,java.util.function.BiFunction)>
<java.util.concurrent.BlockingDeque: E poll(long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.BlockingDeque: E element()>
<java.util.SortedSet: java.util.SortedSet headSet(E)>
<java.util.TreeSet: E floor(E)>
<java.util.concurrent.LinkedBlockingDeque: boolean offer(E)>
<java.util.TreeSet: java.util.NavigableSet subSet(E,boolean,E,boolean)>
<java.util.AbstractMap.SimpleEntry: void <init>(K,V)>
<java.util.concurrent.SynchronousQueue: E poll()>
<java.util.Optional: java.util.Optional of(T)>
<java.util.ArrayDeque: E peekFirst()>
<android.os.Bundle: T getParcelable(java.lang.String)>
<java.util.concurrent.LinkedBlockingDeque: E takeFirst()>
<java.util.Deque: boolean add(E)>
<java.util.concurrent.ConcurrentSkipListSet: E pollFirst()>
<java.util.Deque: E pollFirst()>
<java.util.stream.Stream: R collect(java.util.stream.Collector)>
<android.util.SparseArray: E valueAt(int)>
<java.util.AbstractList: E get(int)>
<java.util.concurrent.ConcurrentLinkedQueue: boolean offer(E)>
<java.util.concurrent.ConcurrentLinkedDeque: void addLast(E)>
<android.app.LoaderManager.LoaderCallbacks: void onLoadFinished(android.content.Loader,D)>
<java.util.Map: V computeIfAbsent(K,java.util.function.Function)>
<java.util.concurrent.BlockingDeque: E peek()>
<java.util.concurrent.ConcurrentSkipListMap: java.util.concurrent.ConcurrentNavigableMap headMap(K)>
<android.util.Property: V get(T)>
<android.util.Pair: void <init>(F,S)>
<java.security.AlgorithmParameters: T getParameterSpec(java.lang.Class)>
<java.util.Collections: boolean replaceAll(java.util.List,T,T)>
<java.util.concurrent.CopyOnWriteArrayList: int indexOf(E,int)>
<android.animation.PropertyValuesHolder: android.animation.PropertyValuesHolder ofMultiFloat(java.lang.String,android.animation.TypeConverter,android.animation.TypeEvaluator,V...)>
<java.util.concurrent.ForkJoinTask: V get()>
<java.util.concurrent.LinkedBlockingDeque: E takeLast()>
<java.util.concurrent.atomic.AtomicReference: V get()>
<java.util.concurrent.atomic.AtomicStampedReference: V get(int[])>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: long getAndIncrement(T)>
<java.util.Map: V merge(K,V,java.util.function.BiFunction)>
<java.util.concurrent.atomic.AtomicLongFieldUpdater: long incrementAndGet(T)>
<java.util.Dictionary: V get(java.lang.Object)>
<java.lang.InheritableThreadLocal: T childValue(T)>
<android.hardware.camera2.CaptureRequest.Builder: void set(android.hardware.camera2.CaptureRequest.Key,T)>
<java.util.concurrent.PriorityBlockingQueue: boolean offer(E)>
<java.util.Collection: boolean add(E)>
<java.util.stream.Stream: T reduce(T,java.util.function.BinaryOperator)>
<android.content.AsyncTaskLoader: void onCanceled(D)>
<java.util.Map: V putIfAbsent(K,V)>
<java.util.concurrent.ConcurrentLinkedDeque: E remove()>
<java.util.function.BiFunction: R apply(T,U)>
<com.android.internal.util.Predicate: boolean apply(T)>
<java.util.Vector: void insertElementAt(E,int)>
<android.os.RemoteCallbackList: void onCallbackDied(E,java.lang.Object)>
<java.util.LinkedList: E removeFirst()>
<android.os.RemoteCallbackList: void onCallbackDied(E)>
<java.util.TreeMap: K ceilingKey(K)>
<java.util.concurrent.atomic.AtomicMarkableReference: void <init>(V,boolean)>
<android.util.ArrayMap: V setValueAt(int,V)>
<java.util.concurrent.LinkedBlockingDeque: E pollFirst()>
<java.util.concurrent.atomic.AtomicStampedReference: boolean weakCompareAndSet(V,V,int,int)>
<android.util.Range: android.util.Range create(T,T)>
<java.util.Hashtable: V putIfAbsent(K,V)>
<java.util.concurrent.atomic.AtomicIntegerFieldUpdater: boolean compareAndSet(T,int,int)>
<java.security.AccessController: T doPrivileged(java.security.PrivilegedAction,java.security.AccessControlContext)>
<java.util.concurrent.PriorityBlockingQueue: void put(E)>
<java.util.TreeSet: E ceiling(E)>
<java.util.concurrent.Executors: java.util.concurrent.Callable callable(java.lang.Runnable,T)>
<javax.security.auth.Subject: T doAs(javax.security.auth.Subject,java.security.PrivilegedExceptionAction)>
<java.util.SortedMap: java.util.SortedMap headMap(K)>
<java.util.concurrent.ForkJoinTask: V get(long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.ConcurrentLinkedDeque: void addFirst(E)>
<java.util.Queue: E remove()>
<android.util.ArrayMap: V remove(java.lang.Object)>
<java.util.LinkedList: E peekLast()>
<java.util.concurrent.CopyOnWriteArrayList: int lastIndexOf(E,int)>
<java.util.concurrent.LinkedBlockingDeque: E getLast()>
<java.util.ArrayDeque: void addLast(E)>
<java.util.concurrent.ConcurrentMap: V putIfAbsent(K,V)>
<java.util.LinkedList: E pollFirst()>
<android.widget.AutoCompleteTextView: void setAdapter(T)>
<java.util.stream.Stream: R collect(java.util.function.Supplier,java.util.function.BiConsumer,java.util.function.BiConsumer)>
<java.util.concurrent.RecursiveTask: V getRawResult()>
<java.util.AbstractList: E remove(int)>
<java.lang.Package: T getAnnotation(java.lang.Class)>
<java.util.Map: V put(K,V)>
<java.util.concurrent.LinkedBlockingDeque: E poll(long,java.util.concurrent.TimeUnit)>
<java.util.concurrent.CompletableFuture: T get()>
<java.util.EventListenerProxy: T getListener()>
<java.util.LinkedList: E remove()>
<java.util.Deque: E peekLast()>
<java.util.concurrent.PriorityBlockingQueue: boolean offer(E,long,java.util.concurrent.TimeUnit)>
<java.lang.Enum: int compareTo(E)>
<java.util.concurrent.atomic.AtomicMarkableReference: V getReference()>
<java.util.LinkedList: E peek()>
<android.util.ArraySet: boolean add(E)>
<java.util.AbstractMap.SimpleEntry: V setValue(V)>
<java.util.concurrent.atomic.AtomicReferenceFieldUpdater: V get(T)>
<java.util.stream.Stream: java.util.stream.Stream of(T)>
<java.util.concurrent.ConcurrentSkipListMap: K firstKey()>
<java.util.concurrent.ConcurrentLinkedDeque: boolean offerLast(E)>
<android.util.LongSparseArray: void append(long,E)>
<java.util.AbstractMap.SimpleImmutableEntry: K getKey()>
<java.util.concurrent.PriorityBlockingQueue: E take()>
<android.util.LruCache: V get(K)>
<android.content.ContentProvider: android.os.ParcelFileDescriptor openPipeHelper(android.net.Uri,java.lang.String,android.os.Bundle,T,android.content.ContentProvider.PipeDataWriter)>
<android.os.Parcelable.ClassLoaderCreator: T createFromParcel(android.os.Parcel,java.lang.ClassLoader)>
<java.util.NavigableMap: K higherKey(K)>
<java.util.Iterator: E next()>
<java.util.concurrent.CopyOnWriteArrayList: boolean addIfAbsent(E)>
<java.util.concurrent.CompletableFuture: boolean complete(T)>
<java.util.concurrent.ConcurrentHashMap.KeySetView: V getMappedValue()>
<java.util.concurrent.atomic.AtomicReferenceArray: boolean compareAndSet(int,E,E)>
<java.util.stream.Stream: java.util.stream.Stream of(T...)>
<java.util.Queue: E element()>
<java.util.LinkedList: E pollLast()>
<java.util.TreeMap: java.util.Map.Entry lowerEntry(K)>
<java.util.concurrent.ConcurrentHashMap: V replace(K,V)>
<android.util.ArrayMap: V get(java.lang.Object)>
<java.util.concurrent.ConcurrentSkipListMap: java.util.Map.Entry floorEntry(K)>
<java.util.function.LongFunction: R apply(long)>
<java.util.ArrayDeque: boolean offer(E)>
<java.security.AccessController: T doPrivileged(java.security.PrivilegedAction)>
<java.util.function.ObjDoubleConsumer: void accept(T,double)>
<java.util.concurrent.LinkedBlockingDeque: E removeLast()>
<java.util.concurrent.BlockingDeque: E takeLast()>
<android.test.ActivityUnitTestCase: T startActivity(android.content.Intent,android.os.Bundle,java.lang.Object)>
<java.util.Vector: E lastElement()>
<java.lang.reflect.TypeVariable: D getGenericDeclaration()>
<java.util.concurrent.ConcurrentLinkedDeque: E peekFirst()>
<java.util.Deque: E pollLast()>
<java.util.concurrent.atomic.AtomicReference: V getAndSet(V)>
<android.test.InstrumentationTestCase: T launchActivity(java.lang.String,java.lang.Class,android.os.Bundle)>
